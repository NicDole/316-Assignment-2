\documentclass[12pt]{article}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{array}
\usepackage{hyperref}

\geometry{margin=1in}

\title{ECSE 316 -- Assignment 2 \\ Fast Fourier Transform and Applications}
\author{
S. Nicolas Dolgopolyy (261115875) \\
Matthew Eiley (261177542)
}
\date{Fall 2025}

\begin{document}
\maketitle

\begin{abstract}
This report presents the implementation and analysis of a complete Fast Fourier Transform (FFT) system for ECSE~316 Assignment~2. The project includes developing a naïve Discrete Fourier Transform (DFT), an optimized Cooley--Tukey FFT, their inverse transforms, 2D extensions, frequency--domain image denoising, Fourier--based image compression, and runtime comparison experiments. Results confirm theoretical performance expectations and demonstrate practical applications of Fourier analysis in image processing.
\end{abstract}

\section{Introduction}
The Discrete Fourier Transform (DFT) is a fundamental tool for analyzing signals and images in the frequency domain. Although the DFT provides an exact representation of frequency content, its direct computation requires $O\left(N^2\right)$ operations, making it impractical for large signals or 2D data such as images. The Fast Fourier Transform (FFT), specifically the Cooley–Tukey algorithm, reduces this cost to $O\left(N\log N\right)$ by exploiting symmetries in the DFT and applying a divide-and-conquer strategy.\\
\\
The goal of this assignment is to implement both the naïve DFT and the FFT from first principles, use them to compute 1D and 2D transforms, and apply these transforms to real image-processing tasks. We build our own FFT rather than relying on library functions, allowing us to explore its algorithmic structure, understand the reason behind its significant speed advantage, and verify its correctness through comparison with NumPy’s implementations.\\
\\
Beyond computing transforms, the assignment also demonstrates practical uses of the FFT, including frequency-domain denoising, image compression by coefficient thresholding, and empirical runtime analysis. Together, these components highlight both the mathematical foundations and real-world utility of Fourier-based techniques in signal and image processing.


\section{Design}
Our implementation follows a modular, bottom-up design that builds the full 2D FFT system from small, well-defined components. The main idea is to implement the core numerical operations ourselves (as required) while relying on NumPy and Matplotlib only for array manipulation and visualization.

\subsection{Design of the 1D Transforms}

\subsubsection{Naïve 1D DFT}

The function \verb|dft_naive_1d| directly evaluates the DFT definition. For each output frequency index $k$, it performs a full loop over all input samples $n$, computing
\[
x_ne^{-2\pi ikn/N}
\]
This double loop structure mirrors the mathematical formula and ensures correctness without optimization. The implementation uses complex NumPy scalars but performs all iteration in pure Python to preserve the $O\left( N^2\right)$ ) behavior required for benchmarking.

\subsubsection{Recrusive 1D FFT (Cooley--Tukey)}

The FFT is implemented in \verb|fft_1d| using the radix-2 Cooley-Tukey divide-and-conquer approach:
\begin{enumerate}
    \item \textbf{Base Case:}\\For inputs of size $N\leq 16$, the algorithm calls \verb|dft_naive_1d|. This avoids recursion overhead on small subproblems and matches typical FFT libraries, which switch to a direct method at small sizes.
    \item \textbf{Divide Step:}\\The input signal is split into even-indexed and odd-indexed elements using Python slicing (\verb|x[0::2]|, \verb|x[1::2]|). 
    \item \textbf{Recursive Step:}\\FFTs of the even and odd halves are computed separately by calling \verb|fft_1d| again.
    \item \textbf{Combine Step:}\\Twiddle factors $e^{-2\pi ik/N}$ are generated once using a vectorized NumPy expression. The two halves are combined into the full spectrum using the standard Cooley–Tukey recombination:
    \[
    X\left[k\right] = E\left[k\right] + \omega_{N}^{k}O\left[k\right], \quad X\left[k+n/2\right] = E\left[k\right] - \omega_{N}^{k}O\left[k\right]
    \]
\end{enumerate}
This design strictly enforces that input lengths be powers of two, so upstream code pads images when necessary.

\subsubsection{Inverse FFT}

The inverse transform \verb|ifft_1d| uses the standard conjugate trick:
\begin{enumerate}
    \item Conjugate the input,
    \item Call the forward FFT,
    \item Conjugate again and divide by N.
\end{enumerate}
This reuses the tested FFT logic, ensuring numerical consistency and minimizing duplicated code.

\subsection{Design of the 2D Transforms}

The 2D transforms reuse the 1D routines exactly, following the mathematical structure of the 2D DFT.

\subsubsection{2D FFT}

\verb|fft_2d| applies \verb|fft_1d| across:
\begin{enumerate}
    \item \textbf{Rows:} Each row is treated as an independent 1D signal.
    \item \textbf{Columns:} After transforming the rows, the algorithm applies \verb|fft_1d| to each column of the intermediate matrix.
\end{enumerate}
This row-then-column approach matches the separability property of the Fourier transform and ensures a total runtime of $O\left(N^2\log N\right)$ for an $N\times N$ image.

\subsubsection{2D Inverse FFT}

\verb|ifft_2d| mirrors the same structure, applying \verb|ifft_1d| across rows and columns. Because \verb|ifft_1d| calls the forward FFT internally, both transforms share the same core logic.

\subsubsection{Naïve 2D FFT}

To enable runtime comparisons, \verb|naive_dft_2d| applies the slow 1D DFT along each row and column, giving the expected cubic runtime $O\left(N^3\right)$. This function is used exclusively in Mode 4 and is not involved in any image operations.

\subsection{Image Preprocessing and Data Handling}

Before applying the FFT, images are loaded in grayscale and converted to floating-point arrays.\\
\\
Because the recursive FFT implementation requires power-of-two dimensions, the helper function \verb|pad_to_power_of_two| pads images with zeros in both dimensions.\\
\\
For visualization, \verb|fftshift_2d| is used (via NumPy’s \verb|fftshift|) solely to center the low-frequency content when plotting spectra. This does not affect the core FFT algorithm since no numerical shortcuts rely on shifting.

\subsection{Application Modes}

The program supports four modes, each built around the core FFT components:
\begin{enumerate}
    \item \textbf{Mode 1 (Visualization):}\\Computes the 2D FFT, shifts it, and displays the magnitude spectrum on a logarithmic scale.
    \item \textbf{Mode 2 (Denoising):}\\Applies a low-frequency circular mask in the frequency domain before performing the inverse FFT. The mask is generated by \verb|low_frequency_mask|.
    \item \textbf{Mode 3 (Compression):}\\Flattens the 2D frequency matrix, sorts coefficients by magnitude, and zeroes out the smallest fraction to achieve multiple compression levels. Each compressed frequency matrix is inverted using \verb|ifft_2d| and displayed.
    \item \textbf{Mode 4 (Runtime Testing):}\\Measures the runtime of \verb|naive_dft_2d| vs. \verb|fft_2d| across increasing matrix sizes and plots mean runtimes with error bars.
\end{enumerate}
Each mode is implemented as an isolated function, making the design easy to extend and ensuring that the FFT code is reused consistently throughout the assignment.

\section{Testing}

To ensure that all components of our DFT and FFT implementations behaved correctly, we performed a series of structured tests on both synthetic data and real images. Our testing strategy focused on three main aspects: numerical correctness, consistency with known properties of the Fourier transform, and performance scaling.

\subsection{Correctness of the 1D Transform Implementations}
We began by testing the 1D naïve DFT and FFT functions on small input vectors where the expected output can be computed manually or compared directly: \begin{itemize}
    \item \textbf{Small synthetic vectors:}\\We generated short arrays of length 4, 8, and 16 consisting of simple patterns (e.g., constant, linear ramp, alternating signs). For each array, we verified that:
    \begin{itemize}
        \item \verb|fft_1d(x)| matched \verb|dft_naive_1d(x)| up to numerical precision.
        \item Applying \verb|ifft_1d(fft_1d(x))| reconstructed the original array with negligible error.
    \end{itemize}
    \item \textbf{Randomized tests:}\\For randomly generated complex vectors, we checked:
    \[
    \verb|ifft_1d(fft_1d(x))|\approx \verb|x|,
    \]
    using the maximum absolute reconstruction error as a criterion.
\end{itemize}
These tests confirmed that the recursive FFT and the inverse transform were implemented correctly and produced the same results as the mathematically direct method.

\subsection{Validation of 2D Transforms}
For the 2D transforms, correctness was assessed through two complementary approaches:
\begin{itemize}
    \item \textbf{Row–column separability check:}\\We verified on small matrices that:
    \begin{itemize}
        \item Applying \verb|fft_1d| manually to rows and then to columns produced the same result as our \verb|fft_2d| implementation.
        \item Likewise, \verb|ifft_2d(fft_2d(A))| recovered the original matrix $A$ up to floating-point tolerance.
    \end{itemize}
    \item \textbf{Comparison with NumPy’s built-in FFT:}\\For randomly generated $N\times N$ matrices and for real image inputs:
    \begin{itemize}
        \item We computed the output of our \verb|fft_2d| and compared it with \verb|np.fft.fft2| after adjusting for the difference in frequency layout (via \verb|fftshift|).
        \item Magnitude and phase differences remained at the level of numerical rounding error.
    \end{itemize}
\end{itemize}
This confirmed that the 2D version correctly extends the 1D FFT and is consistent with standard reference implementations.

\subsection{Image-Domain Sanity Checks}
To ensure correct behavior in practical use:
\begin{itemize}
    \item \textbf{Reconstruction tests:}\\Converting an image to the frequency domain and back using \verb|fft_2d| followed by \verb|ifft_2d| produced images that were visually identical to the input (aside from negligible floating-point noise).
    \item \textbf{High-frequency filtering:}\\In Mode 2, we verified that progressively shrinking the low-pass mask produced smoother images, and turning the mask off entirely restored the original image.
    \item \textbf{Compression behaviour:}\\In Mode 3, we confirmed that thresholding a larger portion of small-magnitude coefficients monotonically increased reconstruction artifacts, as expected in frequency-based compression.
\end{itemize}
These qualitative tests provided additional confidence in the correctness of our frequency-domain manipulations.

\subsection{Runtime Testing}
For Mode 4, we tested the scaling behavior of both algorithms:
\begin{itemize}
    \item We ran both \verb|naive_dft_2d| and \verb|fft_2d| on random matrices of sizes $32,64,\ldots, 1024$.
    \item Each test was repeated 10 times to compute mean runtimes and variances.
    \item The measured scaling trends matched theoretical expectations:
    \begin{itemize}
        \item The naïve method grew approximately as $O\left(N^3\right)$
        \item The FFT grew approximately as $O\left(N^2\log N\right)$
    \end{itemize}
\end{itemize}
This verified not only the correctness but also the efficiency of our FFT implementation.

\section{Analysis}

\subsection{Runtime of Naïve 1D DFT}
The 1D Discrete Fourier Transform directly applies the definition
\[
X_k=\sum_{n=0}^{N-1}x_ne^{-2\pi ikn/N},\qquad k=0,\ldots, N-1
\]
For each of the $N$ output frequencies $X_K$, the algorithm performs a full sum over $N$ input samples. Each term involves a complex multiply and addition, so the total number of basic operations scales with the number of pairs $\left(k,n\right)$, i.e.,
\[
T\left(N\right) =N\cdot N= O\left(N^2\right).
\]
Thus the naïve DFT grows quadratically and becomes impractical for large inputs.

\subsection{FFT Complexity Derivation (1D)}
The Cooley–Tukey Fast Fourier Transform reduces the work by splitting the DFT into its even-indexed and odd-indexed components. This yields the recurrence
\[
T\left(N\right) = 2T\left(\frac{N}{2}\right) + O\left(N\right),
\]
where:
\begin{itemize}
    \item the two subproblems of size $N/2$ come from computing the DFT of the even and odd entries, and
    \item the $O\left(N\right)$ term accounts for combining the two halves using the pre-computed twiddle factors.
\end{itemize}
This recurrence matches the standard divide-and-conquer form analyzed by the Master Theorem. Applying the $T\left(N\right)=2T\left(N/2\right)+N$ case gives:
\[
T\left(N\right) = O\left(N \log N\right).
\]
Therefore, the FFT is exponentially faster than the naïve DFT for large N. 

\subsection{2D Complexity Comparison}

The 2D DFT is computed by applying the 1D transform across all rows and then across all columns (or vice-versa). If the input is an $N\times N$ image, this structure lets us reason about complexity using the 1D results.

\subsubsection*{Naïve 2D DFT}
A single 1D naïve DFT takes $O\left(N^2\right)$.\\
There are $N$ rows and $N$ columns, so performing $2N$ such transformations gives
\[
O\left(N\right)\cdot O\left(N^2\right) + O\left(N\right)\cdot O\left(N^2\right) = O\left(N^3\right).
\]
Thus, the 2D naïve DFT scales cubically with image size.

\subsubsection*{2D FFT}
A single 1D FFT takes $O\left(N \log N\right)$.\\
Applying this to all rows and columns yields
\[
O\left(N\right)\cdot O\left(N\log N\right) + O\left(N\right)\cdot O\left(N\log N\right) = O\left(N^2\log N\right).
\]
We do not need to re-derive the FFT recurrence again as the same divide-and-conquer idea applies independently to each 1D transform. The result is that the 2D FFT achieves a full order-of-magnitude improvement over the naïve method, scaling quasi-linearly in the number of pixels.

\section{Experiments}

\subsection{FFT Visualization (Mode 1)}
\begin{figure}[H]
\centering
\fbox{\rule{0pt}{2in}\rule{3in}{0pt}} % Placeholder
\caption{Original image vs.~log--magnitude FFT visualization.}
\end{figure}

\subsection{Denoising (Mode 2)}
\begin{figure}[H]
\centering
\fbox{\rule{0pt}{2in}\rule{3in}{0pt}} % Placeholder
\caption{Original image (left) and denoised reconstruction (right).}
\end{figure}

The denoising mask successfully removed high--frequency noise while preserving low--frequency structure. Several radius settings were tested to determine optimal smoothing performance.

\subsection{Compression Results (Mode 3)}
\begin{figure}[H]
\centering
\fbox{\rule{0pt}{3in}\rule{5in}{0pt}} % Placeholder
\caption{2$\times$3 grid of compressed images at six compression levels.}
\end{figure}

For each compression level, the number of nonzero coefficients was printed and analyzed. Lower compression preserved quality well, while extremely high compression produced blurred, low--frequency reconstructions.

\subsection{Runtime Benchmarking (Mode 4)}
\begin{figure}[H]
\centering
\fbox{\rule{0pt}{2.5in}\rule{4in}{0pt}} % Placeholder
\caption{Runtime comparison of naïve 2D DFT vs.~2D FFT with error bars.}
\end{figure}

The results closely matched theoretical predictions: the naïve DFT exhibited cubic growth, while the FFT followed an approximately $N^2 \log N$ profile.

\section{Conclusion}
The implementation successfully demonstrated the efficiency advantages of FFT over naïve DFT. Image denoising through frequency masking proved effective, while magnitude--based compression preserved visual features at surprisingly high compression rates. Runtime measurements validated theoretical complexity analyses, showcasing the practical importance of FFT algorithms.

\section*{Appendix}
Additional plots, parameter sweeps, and experimental notes may be added here.

\end{document}