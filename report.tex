\documentclass[12pt]{article}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{float}
\usepackage{caption}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{array}
\usepackage{hyperref}

\geometry{margin=1in}

\title{ECSE 316 -- Assignment 2 \\ Fast Fourier Transform and Applications}
\author{
S. Nicolas Dolgopolyy (261115875) \\
Matthew Eiley (261177542)
}
\date{Fall 2025}

\begin{document}
\maketitle

\begin{abstract}
This report presents the implementation and analysis of a complete Fast Fourier Transform (FFT) system for ECSE~316 Assignment~2. The project includes developing a naïve Discrete Fourier Transform (DFT), an optimized Cooley--Tukey FFT, their inverse transforms, 2D extensions, frequency--domain image denoising, Fourier--based image compression, and runtime comparison experiments. Results confirm theoretical performance expectations and demonstrate practical applications of Fourier analysis in image processing.
\end{abstract}

\section{Introduction}
The Discrete Fourier Transform (DFT) is a fundamental tool for analyzing signals and images in the frequency domain. Although the DFT provides an exact representation of frequency content, its direct computation requires $O\left(N^2\right)$ operations, making it impractical for large signals or 2D data such as images. The Fast Fourier Transform (FFT), specifically the Cooley–Tukey algorithm, reduces this cost to $O\left(N\log N\right)$ by exploiting symmetries in the DFT and applying a divide-and-conquer strategy.\\
\\
The goal of this assignment is to implement both the naïve DFT and the FFT from first principles, use them to compute 1D and 2D transforms, and apply these transforms to real image-processing tasks. We build our own FFT rather than relying on library functions, allowing us to explore its algorithmic structure, understand the reason behind its significant speed advantage, and verify its correctness through comparison with NumPy’s implementations.\\
\\
Beyond computing transforms, the assignment also demonstrates practical uses of the FFT, including frequency-domain denoising, image compression by coefficient thresholding, and empirical runtime analysis. Together, these components highlight both the mathematical foundations and real-world utility of Fourier-based techniques in signal and image processing.


\section{Design}
Our implementation follows a modular, bottom-up design that builds the full 2D FFT system from small, well-defined components. The main idea is to implement the core numerical operations ourselves (as required) while relying on NumPy and Matplotlib only for array manipulation and visualization.

\subsection{Design of the 1D Transforms}

\subsubsection{Naïve 1D DFT}

The function \verb|dft_naive_1d| directly evaluates the DFT definition. For each output frequency index $k$, it performs a full loop over all input samples $n$, computing
\[
x_ne^{-2\pi ikn/N}
\]
This double loop structure mirrors the mathematical formula and ensures correctness without optimization. The implementation uses complex NumPy scalars but performs all iteration in pure Python to preserve the $O\left( N^2\right)$ ) behavior required for benchmarking.

\subsubsection{Recrusive 1D FFT (Cooley--Tukey)}

The FFT is implemented in \verb|fft_1d| using the radix-2 Cooley-Tukey divide-and-conquer approach:
\begin{enumerate}
    \item \textbf{Base Case:}\\For inputs of size $N\leq 16$, the algorithm calls \verb|dft_naive_1d|. This avoids recursion overhead on small subproblems and matches typical FFT libraries, which switch to a direct method at small sizes.
    \item \textbf{Divide Step:}\\The input signal is split into even-indexed and odd-indexed elements using Python slicing (\verb|x[0::2]|, \verb|x[1::2]|). 
    \item \textbf{Recursive Step:}\\FFTs of the even and odd halves are computed separately by calling \verb|fft_1d| again.
    \item \textbf{Combine Step:}\\Twiddle factors $e^{-2\pi ik/N}$ are generated once using a vectorized NumPy expression. The two halves are combined into the full spectrum using the standard Cooley–Tukey recombination:
    \[
    X\left[k\right] = E\left[k\right] + \omega_{N}^{k}O\left[k\right], \quad X\left[k+n/2\right] = E\left[k\right] - \omega_{N}^{k}O\left[k\right]
    \]
\end{enumerate}
This design strictly enforces that input lengths be powers of two, so upstream code pads images when necessary.

\subsubsection{Inverse FFT}

The inverse transform \verb|ifft_1d| uses the standard conjugate trick:
\begin{enumerate}
    \item Conjugate the input,
    \item Call the forward FFT,
    \item Conjugate again and divide by N.
\end{enumerate}
This reuses the tested FFT logic, ensuring numerical consistency and minimizing duplicated code.

\subsection{Design of the 2D Transforms}

The 2D transforms reuse the 1D routines exactly, following the mathematical structure of the 2D DFT.

\subsubsection{2D FFT}

\verb|fft_2d| applies \verb|fft_1d| across:
\begin{enumerate}
    \item \textbf{Rows:} Each row is treated as an independent 1D signal.
    \item \textbf{Columns:} After transforming the rows, the algorithm applies \verb|fft_1d| to each column of the intermediate matrix.
\end{enumerate}
This row-then-column approach matches the separability property of the Fourier transform and ensures a total runtime of $O\left(N^2\log N\right)$ for an $N\times N$ image.

\subsubsection{2D Inverse FFT}

\verb|ifft_2d| mirrors the same structure, applying \verb|ifft_1d| across rows and columns. Because \verb|ifft_1d| calls the forward FFT internally, both transforms share the same core logic.

\subsubsection{Naïve 2D FFT}

To enable runtime comparisons, \verb|naive_dft_2d| applies the slow 1D DFT along each row and column, giving the expected cubic runtime $O\left(N^3\right)$. This function is used exclusively in Mode 4 and is not involved in any image operations.

\subsection{Image Preprocessing and Data Handling}

Before applying the FFT, images are loaded in grayscale and converted to floating-point arrays.\\
\\
Because the recursive FFT implementation requires power-of-two dimensions, the helper function \verb|pad_to_power_of_two| pads images with zeros in both dimensions.\\
\\
For visualization, \verb|fftshift_2d| is used (via NumPy’s \verb|fftshift|) solely to center the low-frequency content when plotting spectra. This does not affect the core FFT algorithm since no numerical shortcuts rely on shifting.

\subsection{Application Modes}

The program supports four modes, each built around the core FFT components:
\begin{enumerate}
    \item \textbf{Mode 1 (Visualization):}\\Computes the 2D FFT, shifts it, and displays the magnitude spectrum on a logarithmic scale.
    \item \textbf{Mode 2 (Denoising):}\\Applies a low-frequency circular mask in the frequency domain before performing the inverse FFT. The mask is generated by \verb|low_frequency_mask|.
    \item \textbf{Mode 3 (Compression):}\\Flattens the 2D frequency matrix, sorts coefficients by magnitude, and zeroes out the smallest fraction to achieve multiple compression levels. Each compressed frequency matrix is inverted using \verb|ifft_2d| and displayed.
    \item \textbf{Mode 4 (Runtime Testing):}\\Measures the runtime of \verb|naive_dft_2d| vs. \verb|fft_2d| across increasing matrix sizes and plots mean runtimes with error bars.
\end{enumerate}
Each mode is implemented as an isolated function, making the design easy to extend and ensuring that the FFT code is reused consistently throughout the assignment.

\section{Testing}

\subsection{Correctness Tests}
Correctness was verified by:
\begin{itemize}
    \item Comparing 1D FFT with \verb|numpy.fft.fft| on small vectors.
    \item Comparing 2D FFT with \verb|numpy.fft.fft2|.
    \item Confirming that IFFT(FFT($x$)) returns $x$ within floating--point tolerance.
\end{itemize}

\subsection{Visual Tests}
The FFT magnitude plots were inspected to confirm expected symmetry and low--frequency dominance. Denoised and compressed images were also visually evaluated.

\subsection{Runtime Validation}
Small timing tests confirmed expected cubic vs.~quasi--quadratic--log behavior for naïve and FFT implementations, respectively.

\section{Analysis}

\subsection{Runtime of Naïve 1D DFT}
The 1D Discrete Fourier Transform directly applies the definition
\[
X_k=\sum_{n=0}^{N-1}x_ne^{-2\pi ikn/N},\qquad k=0,\ldots, N-1
\]
For each of the $N$ output frequencies $X_K$, the algorithm performs a full sum over $N$ input samples. Each term involves a complex multiply and addition, so the total number of basic operations scales with the number of pairs $\left(k,n\right)$, i.e.,
\[
T\left(N\right) =N\cdot N= O\left(N^2\right).
\]
Thus the naïve DFT grows quadratically and becomes impractical for large inputs.

\subsection{FFT Complexity Derivation (1D)}
The Cooley–Tukey Fast Fourier Transform reduces the work by splitting the DFT into its even-indexed and odd-indexed components. This yields the recurrence
\[
T\left(N\right) = 2T\left(\frac{N}{2}\right) + O\left(N\right),
\]
where:
\begin{itemize}
    \item the two subproblems of size $N/2$ come from computing the DFT of the even and odd entries, and
    \item the $O\left(N\right)$ term accounts for combining the two halves using the pre-computed twiddle factors.
\end{itemize}
This recurrence matches the standard divide-and-conquer form analyzed by the Master Theorem. Applying the $T\left(N\right)=2T\left(N/2\right)+N$ case gives:
\[
T\left(N\right) = O\left(N \log N\right).
\]
Therefore, the FFT is exponentially faster than the naïve DFT for large N. 

\subsection{2D Complexity Comparison}

The 2D DFT is computed by applying the 1D transform across all rows and then across all columns (or vice-versa). If the input is an $N\times N$ image, this structure lets us reason about complexity using the 1D results.

\subsubsection*{Naïve 2D DFT}
A single 1D naïve DFT takes $O\left(N^2\right)$.\\
There are $N$ rows and $N$ columns, so performing $2N$ such transformations gives
\[
O\left(N\right)\cdot O\left(N^2\right) + O\left(N\right)\cdot O\left(N^2\right) = O\left(N^3\right).
\]
Thus, the 2D naïve DFT scales cubically with image size.

\subsubsection*{2D FFT}
A single 1D FFT takes $O\left(N \log N\right)$.\\
Applying this to all rows and columns yields
\[
O\left(N\right)\cdot O\left(N\log N\right) + O\left(N\right)\cdot O\left(N\log N\right) = O\left(N^2\log N\right).
\]
We do not need to re-derive the FFT recurrence again as the same divide-and-conquer idea applies independently to each 1D transform. The result is that the 2D FFT achieves a full order-of-magnitude improvement over the naïve method, scaling quasi-linearly in the number of pixels.

\section{Experiments}

\subsection{FFT Visualization (Mode 1)}
\begin{figure}[H]
\centering
\fbox{\rule{0pt}{2in}\rule{3in}{0pt}} % Placeholder
\caption{Original image vs.~log--magnitude FFT visualization.}
\end{figure}

\subsection{Denoising (Mode 2)}
\begin{figure}[H]
\centering
\fbox{\rule{0pt}{2in}\rule{3in}{0pt}} % Placeholder
\caption{Original image (left) and denoised reconstruction (right).}
\end{figure}

The denoising mask successfully removed high--frequency noise while preserving low--frequency structure. Several radius settings were tested to determine optimal smoothing performance.

\subsection{Compression Results (Mode 3)}
\begin{figure}[H]
\centering
\fbox{\rule{0pt}{3in}\rule{5in}{0pt}} % Placeholder
\caption{2$\times$3 grid of compressed images at six compression levels.}
\end{figure}

For each compression level, the number of nonzero coefficients was printed and analyzed. Lower compression preserved quality well, while extremely high compression produced blurred, low--frequency reconstructions.

\subsection{Runtime Benchmarking (Mode 4)}
\begin{figure}[H]
\centering
\fbox{\rule{0pt}{2.5in}\rule{4in}{0pt}} % Placeholder
\caption{Runtime comparison of naïve 2D DFT vs.~2D FFT with error bars.}
\end{figure}

The results closely matched theoretical predictions: the naïve DFT exhibited cubic growth, while the FFT followed an approximately $N^2 \log N$ profile.

\section{Conclusion}
The implementation successfully demonstrated the efficiency advantages of FFT over naïve DFT. Image denoising through frequency masking proved effective, while magnitude--based compression preserved visual features at surprisingly high compression rates. Runtime measurements validated theoretical complexity analyses, showcasing the practical importance of FFT algorithms.

\section*{Appendix}
Additional plots, parameter sweeps, and experimental notes may be added here.

\end{document}